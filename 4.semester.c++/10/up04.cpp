/*
Напишите программу, моделирующую работу детерминированного конечного автомата (ДКА). 
Описание автомата и входная строка вводятся на стандартном потоке ввода. Результат работы автомата над данной строкой выводится на стандартный поток вывода.
Описание автомата задаётся в следующей форме. Сначала задаётся функция перехода автомата. 
Функция перехода задаётся в виде троек
CUR CHAR NEW
где CUR — идентификатор исходного состояния — произвольная символьная строка, не содержащая пробельные символы. 
CHAR — символьная строка длиной ровно 1 символ. NEW — идентификатор целевого состояния — произвольная символьная строка, 
не содержащая пробельные символы. Элементы описания перехода могут отделятся друг от друга произвольным количеством пробельных символов. 
Описание функции перехода завершается строкой END в качестве идентификатора исходного состояния. Элементы CHAR и NEW отсутствуют.
Далее перечисляются заключительные состояния автомата. Каждое состояние — это символьная строка. 
Список состояний завершается символьной строкой END.
Далее задаётся начальное состояние автомата — символьная строка. Затем задаётся проверяемое слово — символьная строка. 
Все элементы входного файла могут отделяться друг от друга произвольным количеством пробельных символов.
Можете предполагать, что входные данные корректны, то есть удовлетворяют спецификации и действительно задают детерминированный конечный автомат.
Результат работы автомата должен быть напечатан в следующем виде. Сначала напечатайте число 1, если данный автомат допускает данную цепочку, 
и 0 в противном случае. Затем напечатайте количество символов, прочитанных во входной цепочке к моменту принятия автоматом решения 
(текущий символ не считается прочитанным). Наконец, напечатайте идентификатор состояния, в котором в данный момент находился автомат.
Автор: Владимир (vk.com/yapoxe) 
*/
#include <iostream>
#include <vector>
#include <algorithm>
#include <map>

int main() {
    int result = 1, count = 0;
    std::vector <std::string> v;
    std::string fstr, sstr, tstr, current_str, tmp_str;
    std::map <std::string, std::map <char, std::string>> cont;
    while(1) {
        std::cin >> fstr;
        if(fstr == "END") {
            break;
        }
        std::cin >> sstr;
        std::cin >> tstr;
        cont[fstr][sstr[0]] = tstr;
    }
    while(1) {
        std::cin >> fstr;
        if(fstr == "END") {
            break;
        }
        v.push_back(fstr);
    }
    std::cin >> current_str >> tmp_str;
    while(1) {
        if(unsigned(count) == tmp_str.length()) {
            auto i = std::find(v.begin(), v.end(), current_str);
            if(i == v.end()) {
                result = 0;
            }
            break;
        }
        auto i = cont[current_str].find(tmp_str[count]);
        if(i == cont[current_str].end()) {
            result = 0;
            break;
        } else {
            current_str = i->second;
            ++count;
        }
    }
    std::cout << result << std::endl;
    std::cout << count << std::endl;
    std::cout << current_str << std::endl;
    return 0;
}