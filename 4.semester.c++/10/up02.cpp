/*
Язык L1 = { anbmcmdn | m, n > 0 }. Для данного целого числа k (0 < k < 1000) напечатайте все строки длины k, 
принадлежащие данному языку, в лексикографическом порядке. 
Запоминать строки в памяти не допускается. Использование вспомогательных переменных не допускается. 
Каждую строку выводите на отдельной строке текста.
Решение реализуйте с помощью рекурсивного спуска, добавляя вместо проверки входной строки генерацию выходной строки. 
В начале решения напишите грамматику для данного языка, допускающую рекурсивный спуск.
Вы можете использовать одну переменную для чтения входного параметра. 
Рекурсивные функции могут принимать не более двух целых параметров: входной параметр и дополнительный параметр генерации.
Автор: Владимир (vk.com/yapoxe) 
*/
#include <iostream>

/*
S > ABCD
A > aA | bB
B > bB | cC
C > cC | dD
D > dD | _
Автор: Владимир (vk.com/yapoxe) 
*/

struct Cl {
    int m, n;
    Cl(int k) : m(k - 1), n(1) {}
};

void A(int n) {
    if(!n) {
        return;
    }
    std::cout << 'a';
    A(n - 1);
}

void B(int n) {
    if(!n) {
        return;
    }
    std::cout << 'b';
    B(n - 1);
}

void C(int n) {
    if(!n) {
        return;
    }
    std::cout << 'c';
    C(n - 1);
}

void D(int n) {
    if(!n) {
        return;
    }
    std::cout << 'd';
    D(n - 1);
}

void Rec(Cl s) {
    while(s.m) {
        A(s.m);
        B(s.n);
        C(s.n);
        D(s.m);
        std::cout << std::endl;
        s.m--;
        s.n++;
    }
}

int main() {
    int n;
    std::cin >> n;
    if(n % 2 || n < 4) {
        return 0;
    }
    Rec(Cl(n / 2));
    return 0;
}