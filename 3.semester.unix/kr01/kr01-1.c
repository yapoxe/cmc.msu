/*
На стандартном потоке ввода до признака конца файла вводится последовательность беззнаковых 32-битных целых чисел. 
Каждое считанное число закодируйте по следующим правилам и на стандартный поток вывода напечатайте байты 
закодированного числа в шестнадцатеричном виде.
Число произвольной битности кодируется последовательностью 8-битных октетов переменной длины. 
Для этого оно разбивается на группы по 7 бит, кодирование в выходную последовательность выполняется 
в порядке от младшей группы к старшей. Старшие (ведущие) нулевые группы бит в выходной поток не кодируются. 
У старшей ненулевой группы бит старший бит не устанавливается, а у всех остальных (младших) кодируемых групп 
бит старший бит устанавливается в 1. Число 0 кодируется октетом 0. Таким образом старший бит октета является флагом 
продолжения и означает, что старшие группы бит числа будут записаны в последующих октетах.
Таким образом, числа от 0 до 127 кодируются одним октетом, числа от 128 до 16383 
кодируются двумя октетами, числа от 16384 до 2097151 кодируются тремя октетами и т. д. 
Число 130 кодируется следующим образом: его двоичное представление 10000010 разбивается 
на группы по 7 бит которые записываются от младшей к старшей: 0000010 0000001. 
Затем у первой (младшей) группы седьмой (старший) бит октета устанавливается равным 1, 
а у второй (старшей) группы - 0. Получаем два октета: 10000010 00000001. В шестнадцатеричном виде они запишутся 82 01.
Автор:
Владимир: https://vk.com/yapoxe
*/

#include <stdio.h>
#include <stdlib.h>

int
main(int argc, char **argv)
{
    unsigned int num;
    unsigned int backup;
    while(scanf("%u", &num) != EOF) {
        if(num != 0) {
            while((num >> 7) != 0) {
                backup = num;
                backup |= 0x00000080;
                backup &= 0x000000FF;
                printf("%x ", backup);
                num >>= 7;
            }
            printf("%02x\n", num);
        } else {
            printf("00\n");
        }
    }
    return 0;
}